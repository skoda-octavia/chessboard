{"ast":null,"code":"import { PieceColor } from \"../pieces/piece\";\nimport { BlackRook } from \"../pieces/piece/infiniteRangePiece/rook/blackRook/black-rook\";\nimport { WhiteRook } from \"../pieces/piece/infiniteRangePiece/rook/whiteRook/white-rook\";\nimport { BlackKing } from \"../pieces/piece/king/blackKing/black-king\";\nimport { WhiteKing } from \"../pieces/piece/king/whiteKing/white-king\";\nexport class CastlingOperator {\n  possibleWhiteCastlings() {\n    var possibleWhiteCastlings = [];\n    if (this.canWhiteQueenSideCastle()) {\n      possibleWhiteCastlings.push([7, 2]);\n    }\n    if (this.canWhiteKingSideCastle()) {\n      possibleWhiteCastlings.push([7, 6]);\n    }\n    return possibleWhiteCastlings;\n  }\n  possibleBlackCastlings() {\n    var possibleBlackCastlings = [];\n    if (this.canBlackQueenSideCastle()) {\n      possibleBlackCastlings.push([0, 2]);\n    }\n    if (this.canBlackKingSideCastle()) {\n      possibleBlackCastlings.push([0, 6]);\n    }\n    return possibleBlackCastlings;\n  }\n  canBlackQueenSideCastle() {\n    if (!(this.fields[0][0].piece instanceof BlackRook) || !(this.fields[0][4].piece instanceof BlackKing)) {\n      return false;\n    }\n    if (this.piecesAlreadyMoved([[0, 0], [0, 4]])) {\n      return false;\n    }\n    if (this.fieldsOccupied([[0, 1], [0, 2], [0, 3]])) {\n      return false;\n    }\n    if (this.fieldsAttacked([[0, 4], [0, 3], [0, 2]], PieceColor.White)) {\n      return false;\n    }\n    return true;\n  }\n  canBlackKingSideCastle() {\n    if (!(this.fields[0][7].piece instanceof BlackRook) || !(this.fields[0][4].piece instanceof BlackKing)) {\n      return false;\n    }\n    if (this.piecesAlreadyMoved([[0, 7], [0, 4]])) {\n      return false;\n    }\n    if (this.fieldsOccupied([[0, 5], [0, 6]])) {\n      return false;\n    }\n    if (this.fieldsAttacked([[0, 4], [0, 5], [0, 6]], PieceColor.White)) {\n      return false;\n    }\n    return true;\n  }\n  canWhiteKingSideCastle() {\n    // king and rook on places\n    if (!(this.fields[7][7].piece instanceof WhiteRook) || !(this.fields[7][4].piece instanceof WhiteKing)) {\n      return false;\n    }\n    if (this.piecesAlreadyMoved([[7, 7], [7, 4]])) {\n      return false;\n    }\n    if (this.fieldsOccupied([[7, 5], [7, 6]])) {\n      return false;\n    }\n    if (this.fieldsAttacked([[7, 4], [7, 5], [7, 6]], PieceColor.Black)) {\n      return false;\n    }\n    return true;\n  }\n  canWhiteQueenSideCastle() {\n    // king and rook on places\n    if (!(this.fields[7][0].piece instanceof WhiteRook) || !(this.fields[7][4].piece instanceof WhiteKing)) {\n      return false;\n    }\n    if (this.piecesAlreadyMoved([[7, 0], [7, 4]])) {\n      return false;\n    }\n    if (this.fieldsOccupied([[7, 1], [7, 2], [7, 3]])) {\n      return false;\n    }\n    if (this.fieldsAttacked([[7, 1], [7, 2], [7, 3]], PieceColor.Black)) {\n      return false;\n    }\n    return true;\n  }\n  arraysAreEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n      return false;\n    }\n    for (let i = 0; i < arr1.length; i++) {\n      if (arr1[i] !== arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  fieldsAttacked(fieldsToCheck, byColor) {\n    var tempPiece;\n    for (let i = 0; i < this.fields.length; i++) {\n      for (let j = 0; j < this.fields[0].length; j++) {\n        if (this.fields[i][j].piece) {\n          tempPiece = this.fields[i][j].piece;\n          if (tempPiece.color = byColor) {\n            var possibleMoves = tempPiece.possibleMoves();\n            for (const subList1 of possibleMoves) {\n              for (const subList2 of fieldsToCheck) {\n                if (this.arraysAreEqual(subList1, subList2)) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n  piecesAlreadyMoved(fields) {\n    try {\n      for (const field of fields) {\n        var height = field[0];\n        var width = field[1];\n        if (this.fields[height][width].piece.alreadyMoved) {\n          return true;\n        }\n      }\n    } catch (error) {\n      console.error(\"invalid fields in castlingOpertor\", error);\n      return true;\n    }\n    return false;\n  }\n  fieldsOccupied(fields) {\n    try {\n      for (const field of fields) {\n        var height = field[0];\n        var width = field[1];\n        if (this.fields[height][width].piece) {\n          return true;\n        }\n      }\n    } catch (error) {\n      console.error(\"invalid fields in castlingOpertor\", error);\n      return true;\n    }\n    return false;\n  }\n  constructor(fields) {\n    this.fields = fields;\n  }\n}","map":{"version":3,"names":["PieceColor","BlackRook","WhiteRook","BlackKing","WhiteKing","CastlingOperator","possibleWhiteCastlings","canWhiteQueenSideCastle","push","canWhiteKingSideCastle","possibleBlackCastlings","canBlackQueenSideCastle","canBlackKingSideCastle","fields","piece","piecesAlreadyMoved","fieldsOccupied","fieldsAttacked","White","Black","arraysAreEqual","arr1","arr2","length","i","fieldsToCheck","byColor","tempPiece","j","color","possibleMoves","subList1","subList2","field","height","width","alreadyMoved","error","console","constructor"],"sources":["C:\\Users\\UÅ¼ytkownik\\Desktop\\student fullstack\\studentManager\\chessboard\\src\\app\\chess\\board\\castling-operator.ts"],"sourcesContent":["import { Field } from \"../field/field\";\r\nimport { PieceColor } from \"../pieces/piece\";\r\nimport { BlackRook } from \"../pieces/piece/infiniteRangePiece/rook/blackRook/black-rook\";\r\nimport { WhiteRook } from \"../pieces/piece/infiniteRangePiece/rook/whiteRook/white-rook\";\r\nimport { BlackKing } from \"../pieces/piece/king/blackKing/black-king\";\r\nimport { WhiteKing } from \"../pieces/piece/king/whiteKing/white-king\";\r\n\r\nexport class CastlingOperator {\r\n\r\n    fields: Field[][];\r\n\r\n\r\n    possibleWhiteCastlings() : number[][] {\r\n        var possibleWhiteCastlings = []\r\n        if (this.canWhiteQueenSideCastle()) {possibleWhiteCastlings.push([7, 2]);}\r\n        if (this.canWhiteKingSideCastle()) {possibleWhiteCastlings.push([7, 6]);}\r\n        return possibleWhiteCastlings;\r\n    }\r\n\r\n    possibleBlackCastlings() : number[][] {\r\n        var possibleBlackCastlings = []\r\n        if (this.canBlackQueenSideCastle()) {possibleBlackCastlings.push([0, 2]);}\r\n        if (this.canBlackKingSideCastle()) {possibleBlackCastlings.push([0, 6]);}\r\n        return possibleBlackCastlings;\r\n    }\r\n\r\n\r\n    canBlackQueenSideCastle() : boolean {\r\n        if (\r\n            !(this.fields[0][0].piece instanceof BlackRook) ||\r\n            !(this.fields[0][4].piece instanceof BlackKing)\r\n        ) { return false;}\r\n\r\n        if ( this.piecesAlreadyMoved([[0, 0], [0, 4]])) { return false;}\r\n        if (this.fieldsOccupied([[0, 1], [0, 2], [0, 3]])) { return false; }\r\n        if (this.fieldsAttacked([[0, 4], [0, 3], [0, 2]], PieceColor.White)) {return false}\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    canBlackKingSideCastle() : boolean {\r\n        if (\r\n            !(this.fields[0][7].piece instanceof BlackRook) ||\r\n            !(this.fields[0][4].piece instanceof BlackKing)\r\n        ) { return false;}\r\n\r\n        if ( this.piecesAlreadyMoved([[0, 7], [0, 4]])) { return false;}\r\n        if (this.fieldsOccupied([[0, 5], [0, 6]])) { return false; }\r\n        if (this.fieldsAttacked([[0, 4], [0, 5], [0, 6]], PieceColor.White)) { return false; }\r\n\r\n        return true;\r\n    }\r\n    canWhiteKingSideCastle(): boolean {\r\n        // king and rook on places\r\n        if (\r\n            !(this.fields[7][7].piece instanceof WhiteRook) ||\r\n            !(this.fields[7][4].piece instanceof WhiteKing)\r\n        ) { return false;}\r\n\r\n        if ( this.piecesAlreadyMoved([[7, 7], [7, 4]])) { return false;}\r\n        if ( this.fieldsOccupied([[7, 5], [7, 6]])) { return false; }\r\n        if (this.fieldsAttacked([[7, 4], [7, 5], [7, 6]], PieceColor.Black)) { return false; }\r\n        \r\n        return true;\r\n    }\r\n\r\n    canWhiteQueenSideCastle(): boolean {\r\n        // king and rook on places\r\n        if (\r\n            !(this.fields[7][0].piece instanceof WhiteRook) ||\r\n            !(this.fields[7][4].piece instanceof WhiteKing)\r\n        ) { return false;}\r\n\r\n        if ( this.piecesAlreadyMoved([[7, 0], [7, 4]])) { return false;}\r\n        if ( this.fieldsOccupied([[7, 1], [7, 2], [7, 3]])) { return false; }\r\n        if ( this.fieldsAttacked([[7, 1], [7, 2], [7, 3]], PieceColor.Black)) {return false;}\r\n\r\n        return true;\r\n    }\r\n\r\n    arraysAreEqual<T>(arr1: T[], arr2: T[]): boolean {\r\n    if (arr1.length !== arr2.length) {\r\n        return false;\r\n    }\r\n\r\n    for (let i = 0; i < arr1.length; i++) {\r\n        if (arr1[i] !== arr2[i]) {\r\n        return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n    }\r\n\r\n    fieldsAttacked(fieldsToCheck: number[][], byColor: PieceColor): boolean {\r\n        var tempPiece;\r\n        for (let i = 0; i < this.fields.length; i++) {\r\n            for (let j = 0; j < this.fields[0].length; j++) {\r\n                if (this.fields[i][j].piece) {\r\n                    tempPiece = this.fields[i][j].piece;\r\n                    if (tempPiece.color = byColor) {\r\n                        var possibleMoves = tempPiece.possibleMoves();\r\n                        for (const subList1 of possibleMoves) {\r\n                            for (const subList2 of fieldsToCheck) {\r\n                                if (this.arraysAreEqual(subList1, subList2)) {\r\n                                    return true;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }    \r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    piecesAlreadyMoved(fields: number[][], ) : boolean {\r\n        try {\r\n            for(const field of fields) {\r\n                var height = field[0]\r\n                var width = field[1]\r\n                if (this.fields[height][width].piece.alreadyMoved) {return true;}\r\n            }\r\n        }\r\n        catch (error) {\r\n            console.error(\"invalid fields in castlingOpertor\", error)\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    fieldsOccupied (fields: number[][], ) : boolean {\r\n        try {\r\n            for(const field of fields) {\r\n                var height = field[0]\r\n                var width = field[1]\r\n                if (this.fields[height][width].piece) {return true;}\r\n            }\r\n        }\r\n        catch (error) {\r\n            console.error(\"invalid fields in castlingOpertor\", error)\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    constructor(fields: Field[][]) {\r\n        this.fields = fields;\r\n    }\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}